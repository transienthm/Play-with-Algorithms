# 有权图的设计
增加一个边的类，邻接表和邻接矩阵中保存的都是类的对象
```
public class Edge<Weight extends Number & Comparable> implements Comparable<Edge>{
	
	private int a, b;//边的两个顶点
	private Weight weight;

	public Edge(int a, int b, Weight weight) {
		this.a = a;
		this.b = b;
		this.weight = weight;
	}

	public Edge(Edge<Weight> e) {
		this.a = e.a;
		this.b = e.b;
		this.weight = e.weight;
	}

	public int v() {
		return a;
	}

	public int w() {
		return b;
	}

	public Weight wt() {
		return weight;
	} 

	public int other(int x) {
		if (x != a && x != b) {
			return -1;
		}

		return x == a ? b : a;
	}
	
	@Override
	public int compareTo(Edge that) {
		return 0;
	}

	@Override
	public String toString() {
		return "" + a + "-" + ": " + weight;
	}
}
```

加权图的接口
```
public interface WeightedGraph<Weight extends Number & Comparable>  {
	public int getNodesCount();
	public int getEdgesCount();
	public void addEdge(Edge<Weight> e);
	public boolean hasEdge(int v, int w);
	public void show();
	public Iterable<Edge<Weight>> adj(int v);
}
```

## 邻接表
```
import java.util.List;
import java.util.ArrayList;

public class SparseWeightedGraph<Weight extends Number & Comparable> implements WeightedGraph {
	private int n;
	private int m;
	private boolean directed;
	private List<Edge<Weight>>[] g;

	public SparseWeightedGraph(int n, boolean directed) {
		if (n < 0) {
			return;
		}
		this.n = n;
		this.directed = directed;
		this.g = (ArrayList<Edge<Weight>>)new ArrayList[n];

		for (int i = 0; i < n; i++) {
			g[i] = new ArrayList<Edge<Weight>>();
		}
	}

	@Override
	public int getNodesCount() {
		return n;
	}

	@Override
	public int getEdgesCount() {
		return m;
	}

	@Override
	public boolean hasEdge(int v, int w) {
		if (!isLegal(v) || !isLegal(w)) {
			return false;
		}

		for (Edge e : g.adj(v)) {
			if (e.other(v) == w) {
				return true;
			}
		}
		return false;
	}

	@Override
	public void addEdge(Edge e) {
		if (e == null) {
			return;
		}

		int v = e.v();
		int w = e.w();

		if (!isLegal(v) || !isLegal(w)) {
			return;
		}

		g[v].add(new Edge(e));


		if (v != w && !directed) {
			g[w].add(new Edge(w, v, e.wt()));
		}

		m++;
	}

	@Override 
	public Iterable<Edge<Weight>> adj(int v) {
		List<Edge<Weight>> res = new ArrayList<>();
		if (!isLegal(v)) {
			return res;
		}

		return g[v];
	}

	@Override
	public void show() {
	    for( int i = 0 ; i < n ; i ++ ){
	        System.out.print("vertex " + i + ":\t");
	        for( int j = 0 ; j < g[i].size() ; j ++ ){
	            Edge e = g[i].get(j);
	            System.out.print( "( to:" + e.other(i) + ",wt:" + e.wt() + ")\t");
	        }
	        System.out.println();
    	}
	}

	private boolean isLegal(int i) {
		return i >= 0 && i < n;
	}
}
```

在此处任性地增加一段知识点

| Summary of Queue methods |
| Method | Throws exception |	Returns special value |
| -- | -- | -- |
| Insert | add(e) | offer(e) |
| Remove | remove() |	poll() |
| Examine | element() | peek() |

# 最小生成树
针对带权无向图 针对连通图

找v-1条边，连接v个节点，使总权值最小
## 切分定理
把图中的节点分为两部分，成为一个切分(Cut).
如果一个边的两个商品，属于切分(Cut)不同的两边，这个边称为横切边。
![default](https://user-images.githubusercontent.com/16509581/39419644-5f8d00da-4c93-11e8-88e8-846715529b58.png)

切分定理：
给定任意切分，横切边中权值最小的边必然属于最小生成树。
![default](https://user-images.githubusercontent.com/16509581/39419687-91a499b6-4c93-11e8-9337-110e273ee345.png)

## Lazy Prim算法
Lazy prim的时间复杂度O(ElogE),E为边数
需要维护一个最小堆
```
import java.lang.reflect.Array;

public class MinHeap<T extends Comparable> {
	private T[] data;
	private int count;
	private int capacity;
	private Class<T> type;

	public MinHeap(int capacity, Class<T> type) {
		this.capacity = capacity;
		this.count = 0;
		this.type = type;
		data = (T[]) Array.newInstance(type, capacity + 1);
	}

	public int size() {
		return count;
	}

	public boolean isEmpty() {
		return count == 0;
	}

	public void insert(T item) {
		if (count + 1 >= capacity && capacity * 2 + 1 < Integer.MAX_VALUE) {
			this.capapcity *= 2;
			T[] newData = (T[]) Array.newInstance(this.type, this.capacity + 1);
			System.arraycopy(data, 0, newData, 0, count + 1);
			data = newData;
		}

		data[++count] = item;
		shiftUp(count);
	}

	private void shiftUp(int v) {
		while (v > 1 && data[v].compareTo(data[v / 2]) < 0) {
			swap(data, v, v / 2);
			v /= 2;
		}
	}

	public T extractMin() {
		if (count <= 0) {
			return null;
		}

		T res = data[1];
		swap(data, 1, count--);
		shiftDown(1);
		return res;
	}

	private void shiftDown(int k) {
		while (k * 2 <= count) {
			int j = k * 2;
			if (j + 1 < count && data[j + 1].compareTo(data[j]) < 0) {
				j++;
			}

			if (data[k].compareTo(data[j]) <= 0) {
				break;
			}
			swap(data, k, j);
			k = j;
		}
	}

	private void swap(T[] data, int i, int j) {
		T t = data[i];
		data[i] = data[j];
		data[j] = t;
	}
}
```

lazy prim实现
```
public class LazyPrimMST<Weight extends Number & Comparable> {
	private MinHeap<Edge<Weight>> minHeap;
	private List<Edge<Weight>> mst;
	private Number mstWeight;
	private Graph g;
	private boolean[] marked;

	public LazyPrimMST(Graph g) {
		this.g = g;
		int n = g.getNodesCount();
		int m = g.getEdgesCount();
		minHeap = new MinHeap<>(Edge.class, m);
		marked = new boolean[n];

		visit(0);

		while (!minHeap.isEmpty()) {
			Edge<Weight> e = minHeap.extractMin();

			//这条边已经不是横切边了
			if (marked[e.v()] == markded[e.w()]) {
				continue;
			}

			//不然的话，这条横切边应该在最小生成树中，将其加入list
			mst.add(e);

			if (marked[e.v()]) {
				visit(e.w());
			} else {
				visit(e.v());
			}
		}

		mstWeight = mst.get(0).wt();
		for (int i = 1; i < mst.size(); i++) {
			mstWeight += mst.get(i).wt();
		}
	} 

	//处于还未处于的结点，发现横切边，将横切边存入最小堆中
	private void visit(int k) {
		if (marked[k]) {
			return;
		}

		marked[k] = true;

		for (Edge<Weight> e : g.adj(v)) {
			//如果这是一条横切边
			if (!marked[e.other(v)]) {
				minHeap.insert(e);
			}
		}
	}
}
```
## Kruskal算法
需要采用并查集的算法，用来判断是否存在环