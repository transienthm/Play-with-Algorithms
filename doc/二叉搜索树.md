# 二叉搜索树
查找问题是计算机中非常重要的基础问题

## 二分查找法
对于有序数组，才能使用二分查找法(排序作用)
```
public class BinarySearch {
    public static int binarySearch(Comparable[] arr, Comparable target) {

        if (arr == null || arr.length == 0) {
            return -1;
        }
        int n = arr.length;
        int l = 0, r = n - 1;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (arr[mid].compareTo(target) == 0) {
                return mid;
            } else if (arr[mid].compareTo(target) > 0) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }

        return -1;
    }
}
```
总结：
1. int mid = (low + high) / 2;如果low 和 high足够大时，low + high会越界。更好的写法为int mid = low + (high - low) / 2;
2. compareTo
    Returns:
a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.It is strongly recommended, but not strictly required that (x.compareTo(y)==0) == (x.equals(y)). 

### floor算法的实现
```
    public static int floor(Comparable[] arr, Comparable target) {
        if (arr == null || arr.length == 0) {
            return -1;
        }

        if (arr[0].compareTo(target) > 0) {
            return -1;
        }

        int n = arr.length;
        int l = 0, r = n - 1;
        int floor = 0;
        boolean found = false;
        while (l < r) {
            floor = l + (r - l) / 2;
            if (arr[floor].compareTo(target) == 0) {
                found = true;
                break;
            } else if (arr[floor].compareTo(target) > 0) {
                r = floor - 1;
            } else {
                l = floor + 1;
            }
        }
        if (found) {
            while (floor >= 1 && arr[floor - 1].compareTo(arr[floor]) == 0) {
                floor--;
            }
            return floor;
        } else {
            if (l == r) {
                if (arr[l].compareTo(target) < 0) {
                    return l;
                } else {
                    return (l - 1) >= 0 ? l - 1 : 0;
                }
            } else {
                return Math.min(l, r);
            }
        }
    }
```
总结：边界条件比较多，但是应该有更优的算法。算法复杂度应该为min(O(logn), O(m)),其中m为target元素重复的个数，即while循环中floor遍历的个数

## 二分搜索树
优势：为实现查找表这种数据结构，也即字典。
|  | 查找元素 | 插入元素 | 删除元素 |
| -- | -- | -- | -- |
| 普通数组 | O(n) | O(n) | O(n) |
| 顺序数组 | O(logn) | O(n) | O(n) |
| 二分搜索树 | O(logn) | O(logn) | O(logn) |










































