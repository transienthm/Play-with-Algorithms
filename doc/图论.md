# 图论Graph theory 基础
研究由点和边组成的数学模型
![graph theory](https://user-images.githubusercontent.com/16509581/39026711-0fc5e694-4481-11e8-8011-5dd2fe471dc1.png)

应用：
交通运输 
社交网络
互联网
工作安排 
脑区活动
程序状态执行

## 图的分类 
![default](https://user-images.githubusercontent.com/16509581/39026750-4e62013a-4481-11e8-9698-97b2515cc053.png)

![2](https://user-images.githubusercontent.com/16509581/39026816-9574b57c-4481-11e8-8293-d30cac12b920.png)

## 图的连通性
![default](https://user-images.githubusercontent.com/16509581/39026898-0329ee2a-4482-11e8-84de-431af045d00a.png)

## 简单图(Simple Graph)
![simple graph](https://user-images.githubusercontent.com/16509581/39027072-cfaab2a4-4482-11e8-8572-ac4e45f5bbf9.png)

# 图的表示 
邻接表适合表示稀疏图(Sparse Graph)
邻接矩阵适合表示稠密图(Dense Graph)
## 邻接矩阵
表示无向图
![default](https://user-images.githubusercontent.com/16509581/39027283-c7325432-4483-11e8-831b-8fa6848f70d0.png)
表示有向图
![default](https://user-images.githubusercontent.com/16509581/39027312-ec0c11d0-4483-11e8-973b-327e75539d05.png)

## 邻接表
表示无向图
![default](https://user-images.githubusercontent.com/16509581/39027348-10729418-4484-11e8-9e4f-469b4e4e52fe.png)

表示有向图
![default](https://user-images.githubusercontent.com/16509581/39027381-2fb766aa-4484-11e8-8cab-782a0ddd70cf.png)

# 图的实现 
邻接矩阵
```
public class DenseGraph {
	private int n; //节点的数量
	private int m; //边的数量
	private boolean directed; // 是否为有向图
	private boolean[][] g;// 图的具体数据

	public DenseGraph(int n, boolean directed) {
		this.n = n;
		this.m = 0;
		this.directed = directed;
		g = new boolean[n][n];
	}

	public int V() {
		return n;
	}

	public int E() {
		return m;
	}

	public void addEdge(int v, int w) {
		assert(v >= 0 && v < n);
		assert(w >= 0 && w < n);

		if (hasEdge(v, w)) {
			return;
		}

		g[v][w] = true;

		if (!directed) {
			g[w][v] = true;
		}

		m++;
	}

	public boolean hasEdge(int v, int w) {
		assert(v >= 0 && v < n);
		assert(w >= 0 && w < n);
		return g[v][w];
	}

}
```

邻接表
```
public class SparseGraph {
	private int n, m;//n = node count; m = edge count;
	private boolean directed;
	private Vector<Integer>[] g;

	public SparseGraph(int n, boolean directed) {
		assert n >= 0;
		this.n = n;
		this.m = 0;
		this.directed = directed;
		g = (Vector<Integer>[]) new Vector[n];
		for (int i = 0; i < n; i++) {
			g[i] = new Vector<>();
		}
	}

	public int V() {
		return n;
	}

	public int E() {
		return m;
	}

	public void addEdge(int v, int w) {
		assert v >= 0 && v < n;
		assert w >= 0 && w < n;

		g[v].add(w);
		if (v != w && !directed) {
			g[w].add(v);
		}
		m++;
	}

	public boolean hasEdge(int v, int w) {
		assert v >= 0 && v < n;
		assert w >= 0 && w < n;

		for (int i = 0; i < g[v].size(); i++) {
			if (g[v].elementAt(i) == w) {
				return true;
			}
		}
		return false;
	}
}
```

# 遍历边


